"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TikTokLIVEApi = exports.TikTokLIVEApiFactory = exports.TikTokLIVEApiFp = exports.TikTokLIVEApiAxiosParamCreator = exports.UpdateKeyUpdateByEnum = exports.GetKeyRetrieveByEnum = exports.DeleteKeyDeleteByEnum = exports.AuthenticationApi = exports.AuthenticationApiFactory = exports.AuthenticationApiFp = exports.AuthenticationApiAxiosParamCreator = exports.AnalyticsApi = exports.AnalyticsApiFactory = exports.AnalyticsApiFp = exports.AnalyticsApiAxiosParamCreator = exports.AlertsApi = exports.AlertsApiFactory = exports.AlertsApiFp = exports.AlertsApiAxiosParamCreator = exports.AlertTargetsApi = exports.AlertTargetsApiFactory = exports.AlertTargetsApiFp = exports.AlertTargetsApiAxiosParamCreator = exports.RetrieveAggregateUsagePeriodEnum = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.WebcastFetchPlatform = exports.StreamType = exports.SignTikTokUrlBodyTypeEnum = exports.SignTikTokUrlBodyMethodEnum = exports.ProxyRegion = exports.PeerRole = exports.PeerPresenceTypeEnum = exports.AlertTargetStatus = exports.AlertTargetFormat = exports.AccountScopes = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {number}
 */
exports.AccountScopes = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11
};
/**
 *
 * @export
 * @enum {number}
 */
exports.AlertTargetFormat = {
    NUMBER_1: 1
};
/**
 *
 * @export
 * @enum {number}
 */
exports.AlertTargetStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_4: 4
};
exports.PeerPresenceTypeEnum = {
    Api: 'api',
    Agent: 'agent'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PeerRole = {
    Public: 'public',
    Enterprise: 'enterprise',
    Staging: 'staging'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ProxyRegion = {
    De: 'DE',
    Es: 'ES',
    Fr: 'FR',
    Gb: 'GB',
    Pl: 'PL'
};
exports.SignTikTokUrlBodyMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Options: 'OPTIONS',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD'
};
exports.SignTikTokUrlBodyTypeEnum = {
    Fetch: 'fetch',
    Xhr: 'xhr'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.StreamType = {
    HlsLd: 'hls_ld',
    HlsSd: 'hls_sd',
    FlvLd: 'flv_ld',
    FlvSd: 'flv_sd'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WebcastFetchPlatform = {
    Mobile: 'mobile',
    Web: 'web'
};
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage: async (accountId, from, to, apiKeyId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'accountId', accountId);
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'to', to);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/page_count`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from instanceof Date) ?
                    from.toISOString() :
                    from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = (to instanceof Date) ?
                    to.toISOString() :
                    to;
            }
            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage: async (accountId, from, to, apiKeyId, page, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'accountId', accountId);
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'to', to);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from instanceof Date) ?
                    from.toISOString() :
                    from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = (to instanceof Date) ?
                    to.toISOString() :
                    to;
            }
            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf: async (options = {}) => {
            const localVarPath = `/accounts/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage: async (accountId, period, value, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'accountId', accountId);
            // verify required parameter 'period' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'period', period);
            // verify required parameter 'value' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'value', value);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/aggregate`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countSignUsage(accountId, from, to, apiKeyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countSignUsage(accountId, from, to, apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.countSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignUsage(accountId, from, to, apiKeyId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignUsage(accountId, from, to, apiKeyId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.getSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountSelf(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountSelf(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.retrieveAccountSelf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAggregateUsage(accountId, period, value, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAggregateUsage(accountId, period, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.retrieveAggregateUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage(accountId, from, to, apiKeyId, options) {
            return localVarFp.countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage(accountId, from, to, apiKeyId, page, options) {
            return localVarFp.getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf(options) {
            return localVarFp.retrieveAccountSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage(accountId, period, value, options) {
            return localVarFp.retrieveAggregateUsage(accountId, period, value, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    countSignUsage(accountId, from, to, apiKeyId, options) {
        return (0, exports.AccountsApiFp)(this.configuration).countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getSignUsage(accountId, from, to, apiKeyId, page, options) {
        return (0, exports.AccountsApiFp)(this.configuration).getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAccountSelf(options) {
        return (0, exports.AccountsApiFp)(this.configuration).retrieveAccountSelf(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAggregateUsage(accountId, period, value, options) {
        return (0, exports.AccountsApiFp)(this.configuration).retrieveAggregateUsage(accountId, period, value, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * @export
 */
exports.RetrieveAggregateUsagePeriodEnum = {
    Hour: 'hour',
    Day: 'day'
};
/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
const AlertTargetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId, alertId, createAlertTargetPayload, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'alertId', alertId);
            // verify required parameter 'createAlertTargetPayload' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'createAlertTargetPayload', createAlertTargetPayload);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAlertTargetPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId, alertId, targetId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'alertId', alertId);
            // verify required parameter 'targetId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'targetId', targetId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listAlertTargets', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('listAlertTargets', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId, alertId, targetId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'alertId', alertId);
            // verify required parameter 'targetId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'targetId', targetId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertTargetsApiAxiosParamCreator = AlertTargetsApiAxiosParamCreator;
/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
const AlertTargetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertTargetsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, createAlertTargetPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.createAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId, alertId, targetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.deleteAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.listAlertTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId, alertId, targetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.testAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertTargetsApiFp = AlertTargetsApiFp;
/**
 * AlertTargetsApi - factory interface
 * @export
 */
const AlertTargetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertTargetsApiFp)(configuration);
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
            return localVarFp.createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId, alertId, targetId, options) {
            return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId, alertId, options) {
            return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId, alertId, targetId, options) {
            return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertTargetsApiFactory = AlertTargetsApiFactory;
/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
class AlertTargetsApi extends base_1.BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    deleteAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    listAlertTargets(accountId, alertId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    testAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertTargetsApi = AlertTargetsApi;
/**
 * AlertsApi - axios parameter creator
 * @export
 */
const AlertsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId, createAlertRequest, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAlert', 'accountId', accountId);
            // verify required parameter 'createAlertRequest' is not null or undefined
            (0, common_1.assertParamExists)('createAlert', 'createAlertRequest', createAlertRequest);
            const localVarPath = `/accounts/{account_id}/alerts/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAlertRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlert', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlert', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId, page, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listAlerts', 'accountId', accountId);
            const localVarPath = `/accounts/{account_id}/alerts/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAlert', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAlert', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertsApiAxiosParamCreator = AlertsApiAxiosParamCreator;
/**
 * AlertsApi - functional programming interface
 * @export
 */
const AlertsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId, createAlertRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, createAlertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.createAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.deleteAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.retrieveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertsApiFp = AlertsApiFp;
/**
 * AlertsApi - factory interface
 * @export
 */
const AlertsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertsApiFp)(configuration);
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId, createAlertRequest, options) {
            return localVarFp.createAlert(accountId, createAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(accountId, alertId, options) {
            return localVarFp.deleteAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId, page, options) {
            return localVarFp.listAlerts(accountId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId, alertId, options) {
            return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertsApiFactory = AlertsApiFactory;
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
class AlertsApi extends base_1.BaseAPI {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    createAlert(accountId, createAlertRequest, options) {
        return (0, exports.AlertsApiFp)(this.configuration).createAlert(accountId, createAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    deleteAlert(accountId, alertId, options) {
        return (0, exports.AlertsApiFp)(this.configuration).deleteAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} accountId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    listAlerts(accountId, page, options) {
        return (0, exports.AlertsApiFp)(this.configuration).listAlerts(accountId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    retrieveAlert(accountId, alertId, options) {
        return (0, exports.AlertsApiFp)(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertsApi = AlertsApi;
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
const AnalyticsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options = {}) => {
            const localVarPath = `/analytics/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options = {}) => {
            const localVarPath = `/analytics/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AnalyticsApiAxiosParamCreator = AnalyticsApiAxiosParamCreator;
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
const AnalyticsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AnalyticsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.fetchAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AnalyticsApiFp = AnalyticsApiFp;
/**
 * AnalyticsApi - factory interface
 * @export
 */
const AnalyticsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AnalyticsApiFp)(configuration);
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options) {
            return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options) {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AnalyticsApiFactory = AnalyticsApiFactory;
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends base_1.BaseAPI {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    fetchAgents(options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getHosts(options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
const AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId, jWTCreateConfig, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createJWT', 'accountId', accountId);
            // verify required parameter 'jWTCreateConfig' is not null or undefined
            (0, common_1.assertParamExists)('createJWT', 'jWTCreateConfig', jWTCreateConfig);
            const localVarPath = `/accounts/{account_id}/jwt/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jWTCreateConfig, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId, createKeyPayload, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createKey', 'accountId', accountId);
            // verify required parameter 'createKeyPayload' is not null or undefined
            (0, common_1.assertParamExists)('createKey', 'createKeyPayload', createKeyPayload);
            const localVarPath = `/accounts/{account_id}/api_keys/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createKeyPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId, deleteBy, deleteParam, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'accountId', accountId);
            // verify required parameter 'deleteBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'deleteBy', deleteBy);
            // verify required parameter 'deleteParam' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'deleteParam', deleteParam);
            const localVarPath = `/accounts/{account_id}/api_keys/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (deleteBy !== undefined) {
                localVarQueryParameter['delete_by'] = deleteBy;
            }
            if (deleteParam !== undefined) {
                localVarQueryParameter['delete_param'] = deleteParam;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId, retrieveParam, retrieveBy, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getKey', 'accountId', accountId);
            // verify required parameter 'retrieveParam' is not null or undefined
            (0, common_1.assertParamExists)('getKey', 'retrieveParam', retrieveParam);
            const localVarPath = `/accounts/{account_id}/api_keys/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (retrieveBy !== undefined) {
                localVarQueryParameter['retrieve_by'] = retrieveBy;
            }
            if (retrieveParam !== undefined) {
                localVarQueryParameter['retrieve_param'] = retrieveParam;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listKeys', 'accountId', accountId);
            const localVarPath = `/accounts/{account_id}/api_keys/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId, updateBy, updateParam, updateKeyPayload, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'accountId', accountId);
            // verify required parameter 'updateBy' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateBy', updateBy);
            // verify required parameter 'updateParam' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateParam', updateParam);
            // verify required parameter 'updateKeyPayload' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateKeyPayload', updateKeyPayload);
            const localVarPath = `/accounts/{account_id}/api_keys/update`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (updateBy !== undefined) {
                localVarQueryParameter['update_by'] = updateBy;
            }
            if (updateParam !== undefined) {
                localVarQueryParameter['update_param'] = updateParam;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateKeyPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AuthenticationApiAxiosParamCreator = AuthenticationApiAxiosParamCreator;
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
const AuthenticationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthenticationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId, jWTCreateConfig, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.createJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId, createKeyPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, createKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.createKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId, deleteBy, deleteParam, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId, retrieveParam, retrieveBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.getKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.listKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.updateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AuthenticationApiFp = AuthenticationApiFp;
/**
 * AuthenticationApi - factory interface
 * @export
 */
const AuthenticationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthenticationApiFp)(configuration);
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId, jWTCreateConfig, options) {
            return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId, createKeyPayload, options) {
            return localVarFp.createKey(accountId, createKeyPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId, deleteBy, deleteParam, options) {
            return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId, retrieveParam, retrieveBy, options) {
            return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId, options) {
            return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
            return localVarFp.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthenticationApiFactory = AuthenticationApiFactory;
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends base_1.BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createJWT(accountId, jWTCreateConfig, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createKey(accountId, createKeyPayload, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).createKey(accountId, createKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    deleteKey(accountId, deleteBy, deleteParam, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getKey(accountId, retrieveParam, retrieveBy, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    listKeys(accountId, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * @export
 */
exports.DeleteKeyDeleteByEnum = {
    Value: 'value',
    Id: 'id'
};
/**
 * @export
 */
exports.GetKeyRetrieveByEnum = {
    Value: 'value',
    Id: 'id'
};
/**
 * @export
 */
exports.UpdateKeyUpdateByEnum = {
    Value: 'value',
    Id: 'id'
};
/**
 * TikTokLIVEApi - axios parameter creator
 * @export
 */
const TikTokLIVEApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options = {}) => {
            const localVarPath = `/webcast/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }
            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }
            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }
            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }
            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }
            if (clientEnter !== undefined) {
                localVarQueryParameter['client_enter'] = clientEnter;
            }
            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }
            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options = {}) => {
            const localVarPath = `/webcast/rate_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck: async (retrieveBulkLiveCheckPayload, options = {}) => {
            // verify required parameter 'retrieveBulkLiveCheckPayload' is not null or undefined
            (0, common_1.assertParamExists)('retrieveBulkLiveCheck', 'retrieveBulkLiveCheckPayload', retrieveBulkLiveCheckPayload);
            const localVarPath = `/webcast/bulk_live_check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(retrieveBulkLiveCheckPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo: async (roomId, options = {}) => {
            // verify required parameter 'roomId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveGiftInfo', 'roomId', roomId);
            const localVarPath = `/webcast/gift_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomCover', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomId', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomInfo', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo: async (uniqueId, streamType, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomVideo', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            if (streamType !== undefined) {
                localVarQueryParameter['streamType'] = streamType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (webcastRoomChatPayload, options = {}) => {
            // verify required parameter 'webcastRoomChatPayload' is not null or undefined
            (0, common_1.assertParamExists)('sendRoomChat', 'webcastRoomChatPayload', webcastRoomChatPayload);
            const localVarPath = `/webcast/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webcastRoomChatPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (signTikTokUrlBody, client, options = {}) => {
            // verify required parameter 'signTikTokUrlBody' is not null or undefined
            (0, common_1.assertParamExists)('signWebcastUrl', 'signTikTokUrlBody', signTikTokUrlBody);
            const localVarPath = `/webcast/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signTikTokUrlBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TikTokLIVEApiAxiosParamCreator = TikTokLIVEApiAxiosParamCreator;
/**
 * TikTokLIVEApi - functional programming interface
 * @export
 */
const TikTokLIVEApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TikTokLIVEApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.fetchWebcastURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.getRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveBulkLiveCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGiftInfo(roomId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGiftInfo(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveGiftInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomCover(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomCover(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomVideo(uniqueId, streamType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomVideo(uniqueId, streamType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(webcastRoomChatPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(webcastRoomChatPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.sendRoomChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(signTikTokUrlBody, client, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(signTikTokUrlBody, client, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.signWebcastUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TikTokLIVEApiFp = TikTokLIVEApiFp;
/**
 * TikTokLIVEApi - factory interface
 * @export
 */
const TikTokLIVEApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TikTokLIVEApiFp)(configuration);
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
            return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options) {
            return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
            return localVarFp.retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo(roomId, options) {
            return localVarFp.retrieveGiftInfo(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover(uniqueId, options) {
            return localVarFp.retrieveRoomCover(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId, options) {
            return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId, options) {
            return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo(uniqueId, streamType, options) {
            return localVarFp.retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(webcastRoomChatPayload, options) {
            return localVarFp.sendRoomChat(webcastRoomChatPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(signTikTokUrlBody, client, options) {
            return localVarFp.signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TikTokLIVEApiFactory = TikTokLIVEApiFactory;
/**
 * TikTokLIVEApi - object-oriented interface
 * @export
 * @class TikTokLIVEApi
 * @extends {BaseAPI}
 */
class TikTokLIVEApi extends base_1.BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {ProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    getRateLimits(options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
     * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveGiftInfo(roomId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveGiftInfo(roomId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomCover(uniqueId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomCover(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomId(uniqueId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomInfo(uniqueId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomVideo(uniqueId, streamType, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    sendRoomChat(webcastRoomChatPayload, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).sendRoomChat(webcastRoomChatPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SignTikTokUrlBody} signTikTokUrlBody
     * @param {string} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    signWebcastUrl(signTikTokUrlBody, client, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TikTokLIVEApi = TikTokLIVEApi;
//# sourceMappingURL=api.js.map